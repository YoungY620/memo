{
  "issues": [
    {
      "tags": ["design-decision"],
      "title": "Debounce and max-wait for batching file changes",
      "description": "File changes are batched using two timers: a debounce timer (default 30s) that resets on each new change, and a max-wait timer (default 5min) that forces a flush even if changes keep coming. This prevents excessive AI calls during rapid edits while ensuring changes aren't delayed indefinitely during continuous development.",
      "locations": [
        {
          "file": "watcher.go",
          "keyword": "debounce",
          "line": 131
        },
        {
          "file": "watcher.go",
          "keyword": "maxWait",
          "line": 135
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "Validation loop with feedback prompts",
      "description": "After the AI updates JSON files, a validation step checks schema compliance. If validation fails, the AI receives a feedback prompt with error details and gets up to 5 attempts to fix the issues. This self-healing approach improves reliability without human intervention.",
      "locations": [
        {
          "file": "analyser.go",
          "keyword": "maxRetries",
          "line": 109
        },
        {
          "file": "analyser.go",
          "keyword": "feedbackPrompt",
          "line": 121
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "Optional agent configuration with kimi defaults",
      "description": "The agent.api_key and agent.model fields are optional. If not provided, the kimi-agent-sdk uses its default configuration. This allows zero-config usage for users who have kimi CLI configured, while supporting custom models for advanced users.",
      "locations": [
        {
          "file": "analyser.go",
          "keyword": "kimi defaults",
          "line": 82
        },
        {
          "file": "config.yaml",
          "keyword": "api_key",
          "line": 4
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "Gitignore pattern merging for automatic exclusions",
      "description": "The watcher automatically loads .gitignore patterns and merges them with configured ignore_patterns. This reduces configuration burden and ensures ignored files (like build artifacts, dependencies) are not watched or analyzed. Negation patterns (!pattern) are intentionally skipped as they add complexity.",
      "locations": [
        {
          "file": "config.go",
          "keyword": "MergeGitignore",
          "line": 121
        },
        {
          "file": "config.go",
          "keyword": "negation",
          "line": 84
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "Embedded prompt files for distribution simplicity",
      "description": "Prompts (context.md, analyse.md, feedback.md) are embedded into the binary using Go's embed directive. This allows single-binary distribution without needing to ship separate prompt files, at the cost of requiring a rebuild to change prompts.",
      "locations": [
        {
          "file": "analyser.go",
          "keyword": "embed",
          "line": 6
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "Auto-approve mode for unattended operation",
      "description": "The kimi-agent-sdk session is created with WithAutoApprove(), meaning all tool calls from the AI are automatically approved. This enables fully autonomous operation but means the AI has unrestricted access to the file system within the work directory.",
      "locations": [
        {
          "file": "analyser.go",
          "keyword": "WithAutoApprove",
          "line": 77
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "LineBuffer for streaming output with 500ms timeout",
      "description": "The analyser uses a LineBuffer to accumulate streamed AI output and flush on complete lines or after 500ms timeout. This produces cleaner debug logs with complete lines instead of fragmented tokens. The buffer force-flushes on step completion or StatusUpdate events to ensure no content is lost. See spec/line-buffer-design.md for full design rationale.",
      "locations": [
        {
          "file": "analyser.go",
          "keyword": "NewLineBuffer",
          "line": 140
        },
        {
          "file": "log.go",
          "keyword": "LineBuffer",
          "line": 54
        },
        {
          "file": "spec/line-buffer-design.md",
          "keyword": "LineBuffer",
          "line": 44
        }
      ]
    },
    {
      "tags": ["compromise"],
      "title": "Simple pattern matching for ignore patterns",
      "description": "The ignored() function uses basic string matching and wildcard suffix checking, not full glob/gitignore semantics. Patterns like **/ or complex negations are not fully supported. This is simpler and covers most use cases but may not match gitignore behavior exactly in edge cases.",
      "locations": [
        {
          "file": "watcher.go",
          "keyword": "ignored",
          "line": 75
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "Separation of prompts and design specs into distinct directories",
      "description": "The project uses prompts/ for actual AI prompt templates (context.md, analyse.md, feedback.md) that are embedded in the binary, and spec/ for design specification documents that describe feature rationale and implementation details. This keeps operational files separate from documentation.",
      "locations": [
        {
          "file": "prompts/context.md",
          "keyword": "prompts",
          "line": 1
        },
        {
          "file": "spec/line-buffer-design.md",
          "keyword": "设计文档",
          "line": 1
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "Code as single source of truth with doc-sync tracking",
      "description": "The context.md prompt establishes that code is the single source of truth - the AI should reflect actual code behavior, not what docs or comments claim. Additionally, the AI is restricted to only modifying .memo/index/*.json files and should use the 'outdated-docs' tag to track discrepancies between code and documentation rather than fixing external docs directly. This ensures documentation accuracy while preventing unintended modifications to the codebase.",
      "locations": [
        {
          "file": "prompts/context.md",
          "keyword": "single source of truth",
          "line": 236
        },
        {
          "file": "prompts/context.md",
          "keyword": "outdated-docs",
          "line": 238
        }
      ]
    },
    {
      "tags": ["bug"],
      "title": "Unused 'root' field in Watcher struct",
      "description": "The Watcher struct declares 'root' as part of 'root, debounceMs, maxWaitMs int' but this field is never used. The actual root path is stored in the separate 'rootPath string' field. This appears to be leftover from earlier code and should be cleaned up.",
      "locations": [
        {
          "file": "watcher.go",
          "keyword": "root, debounceMs",
          "line": 14
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "Once Mode for one-shot scanning via public Flush()",
      "description": "The 'once mode' feature performs a single scan and analysis, then exits without entering the watch loop. This is useful for CI/CD pipelines or one-time documentation generation. The key design choice was to make flush() public as Flush(), allowing both normal mode (timer-triggered) and once mode (direct call from main.go after ScanAll) to reuse the same logic. The flow in once mode is: ScanAll() → pending → Flush() → onChange → exit. See spec/feature-once-mode.md for the architecture diagram.",
      "locations": [
        {
          "file": "main.go",
          "keyword": "--once",
          "line": 24
        },
        {
          "file": "main.go",
          "keyword": "onceFlag",
          "line": 136
        },
        {
          "file": "watcher.go",
          "keyword": "Flush()",
          "line": 139
        },
        {
          "file": "spec/feature-once-mode.md",
          "keyword": "Once mode",
          "line": 9
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "Module-by-module thorough analysis workflow",
      "description": "The analyse.md prompt enforces a thorough, module-by-module workflow to ensure no files are skipped during analysis. Instead of reading all files at once and updating index files in a single batch, the AI creates a fine-grained todo list with one item per changed file, groups them by module/directory, reads files one by one marking each as done, and updates index files after completing each module. This prevents context overflow on large changesets and ensures complete coverage.",
      "locations": [
        {
          "file": "prompts/analyse.md",
          "keyword": "Create Todo List",
          "line": 5
        },
        {
          "file": "spec/feature-thorough-analysis.md",
          "keyword": "Thorough Analysis",
          "line": 1
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "MCP mode as separate read-only process",
      "description": "MCP mode runs as a separate process from the watcher, sharing the same .memo/index directory. This separation of concerns means: (1) the watcher maintains the index, (2) MCP provides read-only queries. MCP mode requires existing index and exits with error if not found. This architecture allows running multiple MCP servers against the same index or running MCP without a watcher if manual updates are preferred.",
      "locations": [
        {
          "file": "main.go",
          "keyword": "--mcp",
          "line": 25
        },
        {
          "file": "main.go",
          "keyword": "mcp.Serve",
          "line": 81
        },
        {
          "file": "spec/feature-mcp-query.md",
          "keyword": "MCP server mode",
          "line": 11
        }
      ]
    },
    {
      "tags": ["design-decision", "security"],
      "title": "State machine parser for MCP path queries with strict validation",
      "description": "The MCP query path parser uses a state machine design to handle bracket notation like [arch][modules][0]. It includes security measures: (1) allowed files whitelist (arch, interface, stories, issues), (2) key length limit (100 chars), (3) control character rejection, (4) proper escape sequence handling (\\[, \\], \\\\). This prevents path injection attacks and ensures only valid index files can be accessed.",
      "locations": [
        {
          "file": "mcp/query.go",
          "keyword": "ParsePath",
          "line": 41
        },
        {
          "file": "mcp/query.go",
          "keyword": "allowedFiles",
          "line": 32
        },
        {
          "file": "mcp/query.go",
          "keyword": "validateKey",
          "line": 127
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "MCP tools include schema in description for LLM context",
      "description": "The memo_list_keys and memo_get_value tool descriptions include a summary of the JSON schema for each file type. This provides LLMs with context about what data is available without needing to query first, enabling more efficient navigation of the index.",
      "locations": [
        {
          "file": "mcp/server.go",
          "keyword": "schemaDesc",
          "line": 128
        },
        {
          "file": "mcp/server.go",
          "keyword": "tools()",
          "line": 154
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "MCP tool descriptions include whenToUse guidance for LLMs",
      "description": "MCP tool descriptions embed a 'whenToUse' constant explaining when LLMs should use memo tools FIRST - specifically for understanding, summarizing, exploring, or navigating codebases. Lists typical requests (summarize repo, show architecture, find issues) and explains why memo is better than reading files directly (pre-indexed, structured, efficient, contextual). This guides LLMs to use the indexed documentation before attempting to scan the filesystem.",
      "locations": [
        {
          "file": "mcp/server.go",
          "keyword": "whenToUse",
          "line": 134
        }
      ]
    },
    {
      "tags": ["todo"],
      "title": "arch.json internal submodules testdata not added",
      "description": "The spec/arch-internal-submodules.md spec has an unchecked TODO item for adding testdata test cases for the internal submodules schema. The schema and validator changes were completed, but test data was not added.",
      "locations": [
        {
          "file": "spec/arch-internal-submodules.md",
          "keyword": "testdata",
          "line": 69
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "MCP with Watcher mode via --mcp-with-watcher flag",
      "description": "The --mcp-with-watcher flag runs MCP server + Watcher subprocess together. Architecture: (1) Default mode (no flag): Watcher only, (2) --mcp mode: MCP server only (requires existing index), (3) --mcp-with-watcher mode: spawns 'memo --path <workDir>' as subprocess with stdout/stderr set to nil, then runs MCP server on stdio. Signal handling (SIGINT/SIGTERM) kills the subprocess before exiting. The subprocess is also killed when the MCP server exits normally or with error.",
      "locations": [
        {
          "file": "spec/feature-mcp-default.md",
          "keyword": "--mcp-with-watcher",
          "line": 3
        },
        {
          "file": "main.go",
          "keyword": "mcpWithWatcherFlag",
          "line": 26
        },
        {
          "file": "main.go",
          "keyword": "cmd.Process.Kill",
          "line": 62
        }
      ]
    },
    {
      "tags": ["todo", "design-decision"],
      "title": "Add concurrent analysis guard with mutex in watcher",
      "description": "When multiple Flush() calls overlap (e.g., Timer1 triggers Flush() which starts a long-running Analyse(), then Timer2 triggers another Flush() before Timer1 finishes), both may try to write to index files simultaneously causing conflicts. The solution is to add an 'analysing sync.Mutex' to the Watcher struct and lock/unlock it at the start/end of Flush(). This ensures only one analysis runs at a time - subsequent Flush() calls will block until the previous one completes.",
      "locations": [
        {
          "file": "spec/feature-concurrent-analysis-guard.md",
          "keyword": "Concurrent Analysis Guard",
          "line": 1
        },
        {
          "file": "watcher.go",
          "keyword": "Flush()",
          "line": 139
        }
      ]
    },
    {
      "tags": ["todo"],
      "title": "Configurable LineBuffer timeout",
      "description": "The spec/line-buffer-design.md mentions adding a configurable timeout parameter in config.yaml for the LineBuffer (output.line_buffer_timeout_ms). Currently the timeout is hardcoded to 500ms in analyser.go. This would allow users to tune the timeout for their environment.",
      "locations": [
        {
          "file": "spec/line-buffer-design.md",
          "keyword": "line_buffer_timeout_ms",
          "line": 168
        },
        {
          "file": "analyser.go",
          "keyword": "500 * time.Millisecond",
          "line": 140
        }
      ]
    },
    {
      "tags": ["outdated-docs"],
      "title": "README.md missing documentation for --once and --log-level flags",
      "description": "The README.md Usage section documents --path, --config, and --version flags, and has an MCP Integration section for --mcp-with-watcher. However, it is missing documentation for: --once (one-shot mode for CI/CD) and --log-level (log verbosity override). These flags are implemented in main.go but not documented in the user-facing README.",
      "locations": [
        {
          "file": "README.md",
          "keyword": "## Usage",
          "line": 32
        },
        {
          "file": "main.go",
          "keyword": "flag.Parse",
          "line": 29
        }
      ]
    },
    {
      "tags": ["outdated-docs"],
      "title": "Go version inconsistency between version files",
      "description": "The Go version is specified inconsistently across different files: .go-version says '1.25', .tool-versions says 'golang 1.25.6', and go.mod says 'go 1.25.5'. These should be aligned to avoid confusion for contributors setting up their development environment.",
      "locations": [
        {
          "file": ".go-version",
          "keyword": "1.25",
          "line": 1
        },
        {
          "file": ".tool-versions",
          "keyword": "golang 1.25.6",
          "line": 1
        },
        {
          "file": "go.mod",
          "keyword": "go 1.25.5",
          "line": 3
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "Local MCP config to prevent infinite recursion",
      "description": "To prevent infinite recursion when memo is configured in ~/.kimi/mcp.json, the analyser uses a local MCP config file (.memo/mcp.json) via WithMCPConfigFile(). This isolates the watcher's AI session from the user's global MCP config, preventing memo from recursively spawning itself. The .memo/mcp.json file is created by initIndex() in main.go and can be customized by users to add additional MCP servers for watcher sessions.",
      "locations": [
        {
          "file": "spec/fix-mcp-infinite-recursion.md",
          "keyword": "MCP Infinite Recursion",
          "line": 1
        },
        {
          "file": "analyser.go",
          "keyword": "WithMCPConfigFile",
          "line": 78
        },
        {
          "file": "main.go",
          "keyword": "mcp.json",
          "line": 185
        }
      ]
    },
    {
      "tags": ["todo"],
      "title": "MCP infinite recursion fix needs testing verification",
      "description": "The fix for MCP infinite recursion (using local .memo/mcp.json) was implemented but the spec file (spec/fix-mcp-infinite-recursion.md) has unchecked TODO items: (1) Test that no recursion occurs when memo is in ~/.kimi/mcp.json, (2) Test that watcher analysis still works correctly with the new MCP config isolation. These tests should be added or manually verified.",
      "locations": [
        {
          "file": "spec/fix-mcp-infinite-recursion.md",
          "keyword": "TODO",
          "line": 189
        }
      ]
    },
    {
      "tags": ["todo", "design-decision", "optimization"],
      "title": "Batched analysis for large codebases to prevent context overflow",
      "description": "When the codebase is very large (thousands of files), the file path list alone can exceed the LLM context window limit. The proposed solution includes: (1) Use relative paths instead of absolute paths to reduce token usage, (2) Estimate token usage before analysis and check against context limit, (3) Split files into batches when needed (max 500 files or 50K chars per batch), (4) Process batches sequentially with incremental index updates. Implementation requires changes to analyser.go (AnalysisBatch struct, splitIntoBatches function) and prompts/analyse.md (batch number, working directory context). Optional config fields: max_files_per_batch, max_chars_per_batch, context_reserve_tokens.",
      "locations": [
        {
          "file": "spec/fix-large-codebase-context-overflow.md",
          "keyword": "Context Overflow",
          "line": 1
        },
        {
          "file": "analyser.go",
          "keyword": "Analyse",
          "line": 60
        },
        {
          "file": "prompts/analyse.md",
          "keyword": "changed files",
          "line": 51
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "Watcher single instance lock and analysis status awareness",
      "description": "Two-part solution for watcher reliability, now fully implemented: (1) Watcher Lock - flock on .memo/watcher.lock prevents multiple watchers on same directory, avoiding data corruption. lock.go provides TryLock(memoDir)/Unlock(f) using syscall.Flock with LOCK_EX|LOCK_NB. (2) Analysis Status - .memo/status.json signals ongoing analysis to MCP clients. status.go provides SetStatus()/GetStatus(). The analyser calls SetStatus('analyzing') before and SetStatus('idle') after analysis (via defer). MCP server checks status via getStatus() and adds Warning field to ToolCallResult responses when status is 'analyzing', including time elapsed since analysis started.",
      "locations": [
        {
          "file": "lock.go",
          "keyword": "TryLock",
          "line": 14
        },
        {
          "file": "status.go",
          "keyword": "SetStatus",
          "line": 19
        },
        {
          "file": "analyser.go",
          "keyword": "SetStatus",
          "line": 65
        },
        {
          "file": "mcp/server.go",
          "keyword": "getStatus",
          "line": 114
        },
        {
          "file": "main.go",
          "keyword": "TryLock",
          "line": 115
        },
        {
          "file": "spec/feature-watcher-single-instance.md",
          "keyword": "Watcher Single Instance",
          "line": 1
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "Deterministic session ID to prevent session pollution",
      "description": "Each memo analysis uses a deterministic session ID format 'memo-<workdir-hash>' (e.g., memo-a7c3f2b1) derived from SHA256 hash of the working directory path. This is generated by generateSessionID(workDir) and stored in the Analyser struct. Benefits: (1) Single session per project - analyses can potentially reuse context, (2) Easy identification via 'memo-' prefix, (3) Deterministic - same project always uses same ID, (4) Isolated - different projects have different IDs. The session ID is logged at startup for debugging purposes.",
      "locations": [
        {
          "file": "analyser.go",
          "keyword": "generateSessionID",
          "line": 42
        },
        {
          "file": "analyser.go",
          "keyword": "sessionID",
          "line": 37
        },
        {
          "file": "spec/fix-session-id-pollution.md",
          "keyword": "Session ID Pollution",
          "line": 1
        }
      ]
    }
  ]
}
