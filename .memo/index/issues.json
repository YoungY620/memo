{
  "issues": [
    {
      "tags": ["design-decision"],
      "title": "Debounce and max-wait for batching file changes",
      "description": "File changes are batched using two timers: a debounce timer (default 30s) that resets on each new change, and a max-wait timer (default 5min) that forces a flush even if changes keep coming. This prevents excessive AI calls during rapid edits while ensuring changes aren't delayed indefinitely during continuous development.",
      "locations": [
        {
          "file": "watcher.go",
          "keyword": "debounce",
          "line": 131
        },
        {
          "file": "watcher.go",
          "keyword": "maxWait",
          "line": 135
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "Validation loop with feedback prompts",
      "description": "After the AI updates JSON files, a validation step checks schema compliance. If validation fails, the AI receives a feedback prompt with error details and gets up to 5 attempts to fix the issues. This self-healing approach improves reliability without human intervention.",
      "locations": [
        {
          "file": "analyser.go",
          "keyword": "maxRetries",
          "line": 82
        },
        {
          "file": "analyser.go",
          "keyword": "feedbackPrompt",
          "line": 94
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "Optional agent configuration with kimi defaults",
      "description": "The agent.api_key and agent.model fields are optional. If not provided, the kimi-agent-sdk uses its default configuration. This allows zero-config usage for users who have kimi CLI configured, while supporting custom models for advanced users.",
      "locations": [
        {
          "file": "analyser.go",
          "keyword": "kimi defaults",
          "line": 57
        },
        {
          "file": "config.yaml",
          "keyword": "api_key",
          "line": 4
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "Gitignore pattern merging for automatic exclusions",
      "description": "The watcher automatically loads .gitignore patterns and merges them with configured ignore_patterns. This reduces configuration burden and ensures ignored files (like build artifacts, dependencies) are not watched or analyzed. Negation patterns (!pattern) are intentionally skipped as they add complexity.",
      "locations": [
        {
          "file": "config.go",
          "keyword": "MergeGitignore",
          "line": 121
        },
        {
          "file": "config.go",
          "keyword": "negation",
          "line": 83
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "Embedded prompt files for distribution simplicity",
      "description": "Prompts (context.md, analyse.md, feedback.md) are embedded into the binary using Go's embed directive. This allows single-binary distribution without needing to ship separate prompt files, at the cost of requiring a rebuild to change prompts.",
      "locations": [
        {
          "file": "analyser.go",
          "keyword": "embed",
          "line": 15
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "Auto-approve mode for unattended operation",
      "description": "The kimi-agent-sdk session is created with WithAutoApprove(), meaning all tool calls from the AI are automatically approved. This enables fully autonomous operation but means the AI has unrestricted access to the file system within the work directory.",
      "locations": [
        {
          "file": "analyser.go",
          "keyword": "WithAutoApprove",
          "line": 54
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "LineBuffer for streaming output with 500ms timeout",
      "description": "The analyser uses a LineBuffer to accumulate streamed AI output and flush on complete lines or after 500ms timeout. This produces cleaner debug logs with complete lines instead of fragmented tokens. The buffer force-flushes on step completion or StatusUpdate events to ensure no content is lost. See spec/line-buffer-design.md for full design rationale.",
      "locations": [
        {
          "file": "analyser.go",
          "keyword": "NewLineBuffer",
          "line": 113
        },
        {
          "file": "log.go",
          "keyword": "LineBuffer",
          "line": 54
        },
        {
          "file": "spec/line-buffer-design.md",
          "keyword": "LineBuffer",
          "line": 44
        }
      ]
    },
    {
      "tags": ["compromise"],
      "title": "Simple pattern matching for ignore patterns",
      "description": "The ignored() function uses basic string matching and wildcard suffix checking, not full glob/gitignore semantics. Patterns like **/ or complex negations are not fully supported. This is simpler and covers most use cases but may not match gitignore behavior exactly in edge cases.",
      "locations": [
        {
          "file": "watcher.go",
          "keyword": "ignored",
          "line": 75
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "Separation of prompts and design specs into distinct directories",
      "description": "The project uses prompts/ for actual AI prompt templates (context.md, analyse.md, feedback.md) that are embedded in the binary, and spec/ for design specification documents that describe feature rationale and implementation details. This keeps operational files separate from documentation.",
      "locations": [
        {
          "file": "prompts/context.md",
          "keyword": "prompts",
          "line": 1
        },
        {
          "file": "spec/line-buffer-design.md",
          "keyword": "设计文档",
          "line": 1
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "Code as single source of truth with doc-sync tracking",
      "description": "The context.md prompt establishes that code is the single source of truth - the AI should reflect actual code behavior, not what docs or comments claim. Additionally, the AI is restricted to only modifying .memo/index/*.json files and should use the 'outdated-docs' tag to track discrepancies between code and documentation rather than fixing external docs directly. This ensures documentation accuracy while preventing unintended modifications to the codebase.",
      "locations": [
        {
          "file": "prompts/context.md",
          "keyword": "single source of truth",
          "line": 236
        },
        {
          "file": "prompts/context.md",
          "keyword": "outdated-docs",
          "line": 238
        }
      ]
    },
    {
      "tags": ["bug"],
      "title": "Unused 'root' field in Watcher struct",
      "description": "The Watcher struct declares 'root' as part of 'root, debounceMs, maxWaitMs int' but this field is never used. The actual root path is stored in the separate 'rootPath string' field. This appears to be leftover from earlier code and should be cleaned up.",
      "locations": [
        {
          "file": "watcher.go",
          "keyword": "root, debounceMs",
          "line": 14
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "Once Mode for one-shot scanning via public Flush()",
      "description": "The 'once mode' feature performs a single scan and analysis, then exits without entering the watch loop. This is useful for CI/CD pipelines or one-time documentation generation. The key design choice was to make flush() public as Flush(), allowing both normal mode (timer-triggered) and once mode (direct call from main.go after ScanAll) to reuse the same logic. The flow in once mode is: ScanAll() → pending → Flush() → onChange → exit. See spec/feature-once-mode.md for the architecture diagram.",
      "locations": [
        {
          "file": "main.go",
          "keyword": "--once",
          "line": 23
        },
        {
          "file": "main.go",
          "keyword": "onceFlag",
          "line": 106
        },
        {
          "file": "watcher.go",
          "keyword": "Flush()",
          "line": 139
        },
        {
          "file": "spec/feature-once-mode.md",
          "keyword": "Once mode",
          "line": 9
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "Module-by-module thorough analysis workflow",
      "description": "The analyse.md prompt enforces a thorough, module-by-module workflow to ensure no files are skipped during analysis. Instead of reading all files at once and updating index files in a single batch, the AI creates a fine-grained todo list with one item per changed file, groups them by module/directory, reads files one by one marking each as done, and updates index files after completing each module. This prevents context overflow on large changesets and ensures complete coverage.",
      "locations": [
        {
          "file": "prompts/analyse.md",
          "keyword": "Create Todo List",
          "line": 5
        },
        {
          "file": "spec/feature-thorough-analysis.md",
          "keyword": "Thorough Analysis",
          "line": 1
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "MCP mode as separate read-only process",
      "description": "MCP mode runs as a separate process from the watcher, sharing the same .memo/index directory. This separation of concerns means: (1) the watcher maintains the index, (2) MCP provides read-only queries. MCP mode requires existing index and exits with error if not found. This architecture allows running multiple MCP servers against the same index or running MCP without a watcher if manual updates are preferred.",
      "locations": [
        {
          "file": "main.go",
          "keyword": "--mcp",
          "line": 24
        },
        {
          "file": "main.go",
          "keyword": "mcp.Serve",
          "line": 51
        },
        {
          "file": "spec/feature-mcp-query.md",
          "keyword": "MCP server mode",
          "line": 11
        }
      ]
    },
    {
      "tags": ["design-decision", "security"],
      "title": "State machine parser for MCP path queries with strict validation",
      "description": "The MCP query path parser uses a state machine design to handle bracket notation like [arch][modules][0]. It includes security measures: (1) allowed files whitelist (arch, interface, stories, issues), (2) key length limit (100 chars), (3) control character rejection, (4) proper escape sequence handling (\\[, \\], \\\\). This prevents path injection attacks and ensures only valid index files can be accessed.",
      "locations": [
        {
          "file": "mcp/query.go",
          "keyword": "ParsePath",
          "line": 41
        },
        {
          "file": "mcp/query.go",
          "keyword": "allowedFiles",
          "line": 32
        },
        {
          "file": "mcp/query.go",
          "keyword": "validateKey",
          "line": 127
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "MCP tools include schema in description for LLM context",
      "description": "The memo_list_keys and memo_get_value tool descriptions include a summary of the JSON schema for each file type. This provides LLMs with context about what data is available without needing to query first, enabling more efficient navigation of the index.",
      "locations": [
        {
          "file": "mcp/server.go",
          "keyword": "schemaDesc",
          "line": 103
        },
        {
          "file": "mcp/server.go",
          "keyword": "tools()",
          "line": 109
        }
      ]
    },
    {
      "tags": ["todo"],
      "title": "MCP spec TODO items not yet completed",
      "description": "The feature-mcp-query.md spec file has unchecked TODO items for query.go, query_test.go, server.go, and main.go integration. These items appear to be implemented based on the actual code, but the spec file's TODO list was not updated to reflect completion.",
      "locations": [
        {
          "file": "spec/feature-mcp-query.md",
          "keyword": "TODO",
          "line": 149
        }
      ]
    },
    {
      "tags": ["todo"],
      "title": "arch.json internal submodules testdata not added",
      "description": "The spec/arch-internal-submodules.md spec has an unchecked TODO item for adding testdata test cases for the internal submodules schema. The schema and validator changes were completed, but test data was not added.",
      "locations": [
        {
          "file": "spec/arch-internal-submodules.md",
          "keyword": "testdata",
          "line": 69
        }
      ]
    },
    {
      "tags": ["design-decision"],
      "title": "MCP with Watcher mode via --mcp-with-watcher flag",
      "description": "The --mcp-with-watcher flag runs MCP server + Watcher subprocess together. Architecture: (1) Default mode (no flag): Watcher only, (2) --mcp mode: MCP server only (requires existing index), (3) --mcp-with-watcher mode: spawns 'memo --path <workDir>' as subprocess with stdout/stderr set to nil, then runs MCP server on stdio. Signal handling (SIGINT/SIGTERM) kills the subprocess before exiting. The subprocess is also killed when the MCP server exits normally or with error.",
      "locations": [
        {
          "file": "spec/feature-mcp-default.md",
          "keyword": "--mcp-with-watcher",
          "line": 3
        },
        {
          "file": "main.go",
          "keyword": "mcpWithWatcherFlag",
          "line": 26
        },
        {
          "file": "main.go",
          "keyword": "cmd.Process.Kill",
          "line": 62
        }
      ]
    },
    {
      "tags": ["todo", "design-decision"],
      "title": "Add concurrent analysis guard with mutex in watcher",
      "description": "When multiple Flush() calls overlap (e.g., Timer1 triggers Flush() which starts a long-running Analyse(), then Timer2 triggers another Flush() before Timer1 finishes), both may try to write to index files simultaneously causing conflicts. The solution is to add an 'analysing sync.Mutex' to the Watcher struct and lock/unlock it at the start/end of Flush(). This ensures only one analysis runs at a time - subsequent Flush() calls will block until the previous one completes.",
      "locations": [
        {
          "file": "spec/feature-concurrent-analysis-guard.md",
          "keyword": "Concurrent Analysis Guard",
          "line": 1
        },
        {
          "file": "watcher.go",
          "keyword": "Flush()",
          "line": 139
        }
      ]
    }
  ]
}
