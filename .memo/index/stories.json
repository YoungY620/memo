{
  "stories": [
    {
      "title": "Application Startup Flow",
      "tags": ["call-chain", "initialization", "main"],
      "content": "When memo starts, main.go parses CLI flags (--path, --config, --version, --once, --mcp, --mcp-with-watcher, --log-level). If --version is set, it prints version and exits. Otherwise, it determines the work directory (from --path or cwd). If --mcp-with-watcher is set, it spawns a watcher subprocess ('memo --path <workDir>') with stdout/stderr silenced, sets up signal handlers to kill the subprocess on exit, then runs the MCP server. If --mcp flag is set, it starts MCP server only (requires existing index). For normal modes, it loads config.yaml via LoadConfig, sets the log level (flag takes precedence over config), calls MergeGitignore to add .gitignore patterns, and initIndex creates .memo/index directory with empty JSON files if they don't exist plus .memo/mcp.json for isolated MCP configuration. Finally, it creates an Analyser and Watcher, calls watcher.ScanAll() to trigger initial analysis. If --once flag is set, it calls Flush() directly and exits; otherwise it starts the watcher event loop in a goroutine and waits for SIGINT/SIGTERM to shut down gracefully."
    },
    {
      "title": "File Change Detection and Batching",
      "tags": ["call-chain", "watcher", "debounce"],
      "content": "The Watcher uses fsnotify to monitor all directories under the root (excluding ignored patterns). When a file event occurs (write/create/remove/rename), the watcher checks if the path is ignored. If not, it adds the file to a pending set and starts/resets a debounce timer (default 30 seconds). If no new changes occur within the debounce period, Flush() is called. Alternatively, if changes keep coming, the max-wait timer (default 5 minutes) ensures Flush() is eventually called. The Flush function collects all pending files, clears the set, and calls the onChange callback with the file list."
    },
    {
      "title": "AI Analysis and Validation Loop",
      "tags": ["call-chain", "analyser", "validation"],
      "content": "When the onChange callback fires, it calls analyser.Analyse with the list of changed files. The analyser creates a kimi-agent-sdk session (using configured API key/model or kimi defaults) with a local MCP config file (.memo/mcp.json) to prevent infinite recursion when memo itself is configured in the user's ~/.kimi/mcp.json. A deterministic session ID is generated using generateSessionID(workDir), which hashes the working directory path to create a 'memo-<8-char-hash>' format ID - this allows session reuse for the same project. It loads the context.md and analyse.md prompts, appends the list of changed files, and sends to the AI via runPrompt. The AI operates under a read-only workspace policy where it may ONLY modify the four .memo/index/*.json files and must never modify source code, documentation, or other files. The runPrompt method processes the streamed response using a LineBuffer (500ms timeout) to accumulate tokens into complete lines for cleaner debug output. It handles ApprovalRequest messages by auto-approving, ContentPart messages by buffering text, and StatusUpdate messages by force-flushing. After the AI completes, ValidateIndex checks all JSON files against their schemas. If validation passes, analysis is complete. If validation fails, the analyser loads context.md and feedback.md, appends the error messages, and sends another prompt to fix the issues. This retry loop continues up to 5 times before giving up."
    },
    {
      "title": "Configuration and Gitignore Handling",
      "tags": ["user-story", "config", "gitignore"],
      "content": "Users configure memo via config.yaml with log level, optional agent credentials, and watch settings. The watch.ignore_patterns list specifies files/directories to ignore (defaults: .git, node_modules, .memo, *.log). If a .gitignore file exists in the watched directory, MergeGitignore parses it (skipping comments, empty lines, and negation patterns), normalizes patterns (removes leading/trailing slashes), and adds unique patterns to the ignore list. This ensures memo respects the project's existing gitignore rules without manual configuration."
    },
    {
      "title": "Handling Documentation-Code Discrepancies",
      "tags": ["user-story", "documentation", "sync-tracking"],
      "content": "The AI agent follows a 'Code is Single Source of Truth' principle. When analyzing the codebase, if the agent discovers that documentation (README, comments, etc.) is outdated or doesn't match current code behavior, it does not modify the documentation. Instead, it adds an issue to issues.json with the 'outdated-docs' tag describing what's out of sync. This creates a record for maintainers to review while preserving potentially intentional historical documentation. Examples include: README claiming a feature exists that was removed, comments describing deprecated behavior, or configuration docs that don't reflect current defaults."
    },
    {
      "title": "Once Mode for One-Shot Analysis",
      "tags": ["user-story", "once-mode"],
      "content": "Once mode allows running memo as a one-shot tool instead of a continuous watcher. When --once flag is provided, the flow is: main.go parses the flag → ScanAll() queues all existing files into the pending set → Flush() is called directly (instead of waiting for timer) → onChange triggers analysis → program exits immediately without calling Run(). The key implementation insight is that Flush() is public, allowing both modes to reuse the same method. Normal mode calls it via timer callbacks; once mode calls it directly after ScanAll(). This is useful for CI/CD pipelines, pre-commit hooks, or generating initial documentation without leaving a background process running. See spec/feature-once-mode.md for the architecture diagram."
    },
    {
      "title": "MCP Server Mode for Index Querying",
      "tags": ["user-story", "mcp", "query"],
      "content": "MCP mode provides read-only access to .memo/index files via the Model Context Protocol. When --mcp flag is set, memo starts a JSON-RPC 2.0 server on stdio instead of entering watcher mode. The server exposes two tools: memo_list_keys (returns keys for dict or length for list at a path) and memo_get_value (returns JSON value at a path). Paths use bracket notation like [arch][modules][0][name]. The parser is a state machine that validates against allowed files (arch, interface, stories, issues) and supports escape sequences for special characters. This mode is designed for AI coding agents to query the documentation index without loading all files into context. For convenience, --mcp-with-watcher flag combines both modes: it spawns a watcher subprocess to maintain the index, then runs the MCP server. The subprocess runs 'memo --path <workDir>' with stdout/stderr silenced, and is automatically killed when the MCP server exits or receives SIGINT/SIGTERM. Typical usage: 'memo --mcp-with-watcher --path /project' for a single-command setup, or run 'memo --path /project' in one terminal and 'memo --mcp --path /project' in another for separate processes. MCP-only mode (--mcp) requires the index to already exist and will exit with error if .memo/index is not found."
    }
  ]
}
