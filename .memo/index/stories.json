{
  "stories": [
    {
      "title": "Application Startup Flow",
      "tags": ["call-chain", "initialization", "main"],
      "content": "When memo starts, main.go parses CLI flags (--path, --config, --version, --once, --mcp, --log-level). If --version is set, it prints version and exits. Otherwise, it determines the work directory (from --path or cwd). If --mcp flag is set, it validates that .memo/index exists (required for MCP mode), then starts the MCP server via mcp.Serve(workDir) which reads JSON-RPC requests from stdin and writes responses to stdout. For normal modes (watch/once), it loads config.yaml via LoadConfig, sets the log level (flag takes precedence over config), calls MergeGitignore to add .gitignore patterns. Then initIndex() creates .memo/index directory with empty JSON files if they don't exist, creates .memo/mcp.json for isolated MCP configuration (prevents infinite recursion), and creates .memo/.gitignore to exclude runtime files from version control. After initialization, main.go calls TryLock(memoDir) to acquire single-instance lock, InitHistoryLogger(memoDir) to start logging to .memo/.history, and SetStatus(memoDir, 'idle'). Finally, it creates an Analyser and Watcher, calls watcher.ScanAll() to trigger initial analysis. If --once flag is set, it calls Flush() directly and exits; otherwise it starts the watcher event loop in a goroutine and waits for SIGINT/SIGTERM to shut down gracefully."
    },
    {
      "title": "File Change Detection and Batching",
      "tags": ["call-chain", "watcher", "debounce"],
      "content": "The Watcher uses fsnotify to monitor all directories under the root (excluding ignored patterns). When a file event occurs (write/create/remove/rename), the watcher checks if the path is ignored via the ignored() function which uses simple pattern matching (not full gitignore semantics). If not ignored, it adds the file to a pending set and starts/resets a debounce timer (default 30 seconds). If no new changes occur within the debounce period, Flush() is called. Alternatively, if changes keep coming, the max-wait timer (default 5 minutes) ensures Flush() is eventually called. Flush() includes a concurrent analysis guard using a capacity-1 semaphore channel: it attempts non-blocking acquisition via 'select' with a 'default' case - if the semaphore is already held (analysis in progress), it logs a debug message and returns immediately, leaving files in the pending set for the next timer-triggered flush. If acquired, it stops both timers, collects all pending files, clears the set, and calls the onChange callback. The semaphore is released via 'defer' after the callback completes. For newly created directories, the watcher automatically adds them to its watch list."
    },
    {
      "title": "AI Analysis and Validation Loop",
      "tags": ["call-chain", "analyser", "validation"],
      "content": "When the onChange callback fires, it calls analyser.Analyse with the list of changed files. First, the analyser sets status to 'analyzing' via SetStatus() so MCP clients know data may be changing. It converts absolute paths to relative using toRelativePaths() to reduce token usage, then checks if batching is needed via splitIntoBatches(). If file count exceeds maxFilesPerBatch (100), files are recursively split by directory to keep related files together. Each batch is processed by analyseBatch(): it creates a kimi-agent-sdk session using WithMCPConfigFile(.memo/mcp.json) to isolate from user's global MCP config (preventing infinite recursion if memo is in ~/.kimi/mcp.json), and WithSession(sessionID) using the deterministic session ID generated by generateSessionID(workDir) which hashes the working directory to create 'memo-<8-char-hash>' format. The prompt is built from embedded context.md and analyse.md templates, with batch info appended for multi-batch runs ('Batch X of Y'). runPrompt() sends the prompt and processes streamed response using LineBuffer (500ms timeout) for clean output - it handles ApprovalRequest (auto-approve via WithAutoApprove), ContentPart (buffered text), and StatusUpdate (force flush). After AI completes, ValidateIndex() checks all JSON files against their schemas. If validation fails, the analyser loads feedback.md, appends errors, and sends another prompt. This retry loop continues up to 5 times. Finally, status is set back to 'idle'."
    },
    {
      "title": "Configuration and Gitignore Handling",
      "tags": ["user-story", "config", "gitignore"],
      "content": "Users configure memo via config.yaml with log level, optional agent credentials, and watch settings. The watch.ignore_patterns list specifies files/directories to ignore (defaults: .git, node_modules, .memo, *.log). If a .gitignore file exists in the watched directory, MergeGitignore parses it using LoadGitignore() which reads the file line by line, skipping comments and empty lines, normalizing patterns with normalizeGitignorePattern() (removes leading/trailing slashes), and skipping negation patterns (!pattern) since they add complexity. Unique patterns from .gitignore are added to Config.Watch.IgnorePatterns. This ensures memo respects the project's existing gitignore rules without manual configuration. The ignored() function in watcher.go uses simple string matching: prefix wildcard (*.ext), substring matching (pattern in path), and basename matching."
    },
    {
      "title": "Handling Documentation-Code Discrepancies",
      "tags": ["user-story", "documentation", "sync-tracking"],
      "content": "The AI agent follows a 'Code is Single Source of Truth' principle defined in prompts/context.md. When analyzing the codebase, if the agent discovers that documentation (README, comments, etc.) is outdated or doesn't match current code behavior, it does not modify the documentation. Instead, it adds an issue to issues.json with the 'outdated-docs' tag describing what's out of sync. The AI is restricted to ONLY modifying the four .memo/index/*.json files. This creates a record for maintainers to review while preserving potentially intentional historical documentation. Examples include: README claiming a feature exists that was removed, comments describing deprecated behavior, or configuration docs that don't reflect current defaults."
    },
    {
      "title": "Once Mode for One-Shot Analysis",
      "tags": ["user-story", "once-mode"],
      "content": "Once mode allows running memo as a one-shot tool instead of a continuous watcher. When --once flag is provided, the flow is: main.go parses the flag → initialization (config, lock, status, analyser, watcher) → ScanAll() queues all existing files into the pending set → Flush() is called directly (instead of waiting for timer) → onChange triggers analysis → program exits immediately without calling Run(). The key implementation insight is that Flush() is public, allowing both modes to reuse the same method. Normal mode calls it via timer callbacks; once mode calls it directly after ScanAll(). This is useful for CI/CD pipelines, pre-commit hooks, or generating initial documentation without leaving a background process running."
    },
    {
      "title": "MCP Server Mode for Index Querying",
      "tags": ["user-story", "mcp", "query"],
      "content": "MCP mode provides read-only access to .memo/index files via the Model Context Protocol. When --mcp flag is set, memo validates that .memo/index exists (exits with error if not found, since MCP mode doesn't create/update the index), then starts a JSON-RPC 2.0 server on stdio. The server (mcp/server.go) creates a HistoryLogger to record all requests/responses to .memo/.history for debugging. It exposes two tools: memo_list_keys (returns keys for dict or length for list at a path) and memo_get_value (returns JSON value at a path). Tool descriptions embed whenToUse guidance explaining when LLMs should use memo first (summarize repo, show architecture, etc.) and why it's better than scanning files directly. Paths use bracket notation like [arch][modules][0][name]. The parser (mcp/query.go) is a state machine that validates against allowed files (arch, interface, stories, issues), enforces key length limits (100 chars max), rejects control characters, and supports escape sequences (\\[, \\], \\\\). Before each tool response, getStatus() checks .memo/status.json - if analysis is in progress, a Warning field is added to the response alerting the client that data may be stale, including how long the analysis has been running."
    },
    {
      "title": "History Logging for Debugging",
      "tags": ["call-chain", "debugging", "logging"],
      "content": "Both the MCP server and watcher write structured logs to .memo/.history as JSONL (one JSON object per line). The mcp.HistoryLogger provides a centralized logging mechanism: NewHistoryLogger(memoDir, source) creates a logger, Log(entry) writes a HistoryEntry with auto-incrementing seq number and RFC3339 timestamp. Specialized methods include LogRequest/LogResponse for MCP protocol logging (with ID correlation and duration), LogError/LogInfo/LogDebug for general events. The watcher initializes its logger via InitHistoryLogger(memoDir) in log.go which creates a HistoryLogger with source 'watcher'. The log functions (logError, logInfo, logDebug) write to both stdout (if log level permits) and the history logger. This dual-logging approach provides both real-time visibility and persistent debug logs without cluttering stdout."
    }
  ]
}
