{
  "modules": [
    {
      "name": "main",
      "description": "Application entry point. Parses CLI flags, loads configuration, initializes the .memo directory (creates .memo/index/ with empty JSON files and .memo/mcp.json for isolated MCP config), acquires single-instance lock via TryLock(), initializes status to 'idle', creates the watcher and analyser, and handles graceful shutdown on SIGINT/SIGTERM. Supports four modes: watch mode (default) for continuous monitoring, once mode (--once) for one-shot analysis, MCP mode (--mcp) for read-only index queries via stdio, and MCP-with-watcher mode (--mcp-with-watcher) that spawns a watcher subprocess and runs MCP server together.",
      "interfaces": "Receives CLI flags (--path, --config, --version, --once, --mcp, --mcp-with-watcher, --log-level). Calls config.LoadConfig, TryLock(memoDir) to acquire single-instance lock, SetStatus('idle') to initialize status, creates NewWatcher and NewAnalyser, triggers watcher.ScanAll for initial scan. In once mode, calls watcher.Flush() directly and exits; in MCP mode, calls mcp.Serve() and exits; in MCP-with-watcher mode, spawns watcher subprocess then calls mcp.Serve(); in watch mode, starts watcher.Run() and waits for shutdown signal. On exit, releases lock via defer Unlock() and resets status to 'idle'."
    },
    {
      "name": "config",
      "description": "Configuration management. Loads YAML config file with agent settings (API key, model), watch settings (ignore patterns, debounce/max-wait times), and log level. Also parses .gitignore and merges patterns into the ignore list.",
      "interfaces": "LoadConfig(path) returns *Config. Config.MergeGitignore(workDir) merges .gitignore patterns. Used by main module at startup."
    },
    {
      "name": "watcher",
      "description": "File system watcher using fsnotify. Watches directories recursively, ignores files matching configured patterns, implements debouncing (quiet period) and max-wait logic to batch file change events before triggering analysis.",
      "interfaces": "NewWatcher(root, ignore, debounceMs, maxWaitMs, onChange) creates watcher. ScanAll() queues all existing files. Flush() triggers the onChange callback with pending files (used by once mode or timers). Run() starts event loop. Close() cleans up. Calls onChange callback with batched file list."
    },
    {
      "name": "analyser",
      "description": "AI-powered analysis engine with batching support for large codebases. Uses kimi-agent-sdk to create a session with local MCP config (.memo/mcp.json) to prevent infinite recursion. Generates a deterministic session ID (memo-<8-char-hash>) based on working directory path. Converts absolute paths to relative paths and splits large file lists into batches (max 100 files by default) using recursive directory-based splitting. Each batch is processed sequentially with batch info added to the prompt.",
      "interfaces": "NewAnalyser(cfg, workDir) creates analyser with deterministic session ID. Analyse(ctx, changedFiles) converts to relative paths via toRelativePaths(), splits into batches via splitIntoBatches(threshold=100), then processes each batch via analyseBatch(). Sets status to 'analyzing'/'idle' around the process. analyseBatch() creates AI session, sends prompts with batch info ('Batch X of Y'), runs validation loop with up to 5 retries. Helper functions: generateSessionID(workDir), toRelativePaths(files, workDir), splitIntoBatches(files, threshold), runPrompt(ctx, session, prompt)."
    },
    {
      "name": "validator",
      "description": "JSON schema validator for .memo/index files. Defines schemas for arch.json, interface.json, stories.json, and issues.json. Validates each file against its schema and reports errors. The arch.json schema supports optional 'internal' field with submodules.",
      "interfaces": "ValidateIndex(indexDir) returns ValidationResult. FormatValidationErrors(result) formats errors as string. Called by analyser after each AI response."
    },
    {
      "name": "log",
      "description": "Logging utilities with four levels (error, notice, info, debug) and LineBuffer for streaming output. LineBuffer accumulates text and flushes on newlines, timeout (500ms), or when forced, producing cleaner logs with complete lines instead of fragmented tokens.",
      "interfaces": "SetLogLevel(level) sets global log level. logError/logNotice/logInfo/logDebug functions for logging. NewLineBuffer(timeout) creates a buffer, Write(s) appends text, Flush(force) returns content to output."
    },
    {
      "name": "lock",
      "description": "Watcher single instance lock using flock. Prevents multiple watcher processes from running on the same directory, which would cause race conditions and data corruption when writing to .memo/index/*.json files.",
      "interfaces": "TryLock(memoDir) attempts to acquire exclusive lock on .memo/watcher.lock using syscall.Flock with LOCK_EX|LOCK_NB (non-blocking). Returns file handle if successful, error if another watcher is running. Writes PID to lock file for debugging. Unlock(f) releases the lock. Called by main at startup for watcher/once modes."
    },
    {
      "name": "status",
      "description": "Analysis status management via .memo/status.json. Signals to MCP clients whether analysis is in progress, allowing them to warn users about potentially stale data.",
      "interfaces": "SetStatus(memoDir, status) writes status ('idle' or 'analyzing') to .memo/status.json. When 'analyzing', includes timestamp. GetStatus(memoDir) reads status, returns 'idle' if file missing or invalid. Called by analyser before/after Analyse()."
    },
    {
      "name": "mcp",
      "description": "MCP (Model Context Protocol) server that exposes .memo/index/*.json via safe JSON path query. Provides read-only access to the documentation index via stdio-based JSON-RPC 2.0 protocol. Tool descriptions include embedded LLM guidance (whenToUse) explaining when to use memo tools first for codebase understanding. Checks .memo/status.json before each tool call and adds a 'warning' field to responses when analysis is in progress, alerting clients that data may be stale.",
      "interfaces": "Serve(workDir) starts the MCP server and blocks. Exposes two tools: memo_list_keys and memo_get_value. Server.getStatus() reads .memo/status.json and handleToolCall() adds Warning to ToolCallResult when status is 'analyzing'. Used by main when --mcp flag is set.",
      "internal": {
        "submodules": [
          {
            "name": "server",
            "description": "MCP stdio server handling JSON-RPC 2.0 protocol. Implements initialize, notifications/initialized, tools/list, and tools/call methods. Returns server capabilities and tool definitions with embedded LLM guidance (schemaDesc + whenToUse). Checks analysis status and adds warning to tool responses when analysis is in progress.",
            "interfaces": "NewServer(workDir) creates server with indexDir and memoDir paths. Run() starts event loop reading newline-delimited JSON from stdin. tools() returns Tool definitions with schemas. getStatus() reads .memo/status.json. handleToolCall() checks status and adds Warning field to ToolCallResult if status is 'analyzing'."
          },
          {
            "name": "query",
            "description": "Path parser (state machine) and query executor. Parses bracket notation paths like [arch][modules][0][name], validates against allowed files (arch, interface, stories, issues), supports escape sequences for special characters, and traverses JSON data structures.",
            "interfaces": "ParsePath(path) parses and validates path, returns file name and PathSegment slice. ListKeys(indexDir, path) returns ListKeysResult with type/keys/length. GetValue(indexDir, path) returns GetValueResult with JSON string."
          }
        ],
        "relationships": "server â†’ query: handleToolCall() uses ListKeys() and GetValue() which internally call ParsePath(), loadFile(), and traverse()"
      }
    }
  ],
  "relationships": "## Module Dependencies\n\n```mermaid\ngraph TD\n  main --> config\n  main --> watcher\n  main --> analyser\n  main --> mcp\n  main --> log\n  main --> lock\n  main --> status\n  config --> log\n  watcher --> log\n  analyser --> config\n  analyser --> validator\n  analyser --> log\n  analyser --> status\n  analyser --> prompts[prompts/*.md]\n  analyser --> kimi-agent-sdk\n  validator --> gojsonschema\n  watcher --> fsnotify\n  mcp --> .memo/index\n  mcp --> status\n```\n\n## Directory Organization\n\n- **prompts/** - Embedded prompt templates used by the analyser (context.md, analyse.md, feedback.md)\n- **spec/** - Design specification documents for features and architecture decisions\n- **mcp/** - MCP server package for read-only index queries\n\n## Notes\n\n- **main** is the orchestrator that wires everything together and selects mode (watch/once/mcp/mcp-with-watcher)\n- **watcher** operates independently, calling the onChange callback when files change\n- **analyser** is the core logic that invokes the AI agent and validates output\n- **validator** provides schema validation to ensure AI output is correct\n- **log** provides logging plus LineBuffer for streaming output handling\n- **mcp** provides read-only query interface to the index via MCP protocol\n- **lock** ensures only one watcher runs per directory using flock\n- **status** signals analysis state to MCP clients via .memo/status.json\n- External dependencies: fsnotify (file watching), gojsonschema (validation), kimi-agent-sdk (AI agent), gopkg.in/yaml.v3 (config parsing)"
}
